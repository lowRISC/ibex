
#  -Core Firmware and the RISCV GCC Toolchain (SDK)
include ../../mk/Common.mk




TEST         ?= hello-world
# Test-Program directores.
# Relative path is used for Verilator which cannot seem to handle loooong pathnames.
TEST_PROGRAM_PATH    = $(CORE_V_VERIF)/$(CV_CORE_LC)/tests/programs/custom
TEST_PROGRAM_RELPATH = ../../$(CV_CORE_LC)/tests/programs/custom
#TEST_PROGRAM_RELPATH = $(CORE_V_VERIF)/$(CV_CORE_LC)/tests/programs/custom
TEST_TEST_DIR        := $(TEST_PROGRAM_PATH)/$(TEST)

#TEST_FILES        = $(filter %.c %.S,$(wildcard  $(TEST_TEST_DIR)/*))
TEST_FILES_FULL   = $(filter %.c %.S,$(wildcard $(TEST_TEST_DIR)/*))
TEST_FILES        = $(notdir $(TEST_FILES_FULL))




# Common output directories
RUN_INDEX                ?= 0
SIM_RESULTS              ?= simulation_results
SIM_TEST_RESULTS         = $(SIM_RESULTS)/$(TEST)
SIM_RUN_RESULTS          = $(SIM_TEST_RESULTS)/$(RUN_INDEX)
SIM_TEST_PROGRAM_RESULTS = $(SIM_RUN_RESULTS)/test_program
SIM_BSP_RESULTS          = $(CORE_V_VERIF)/sw/build/bsp

# Compile compile flags for all simulators
SV_CMP_FLAGS =

#top module
VLT_TOP_MODULE     ?= tb_top_verilator

# verilator configuration
VERILATOR           = verilator
VERILATOR_ROOT ?= $(dir $(shell which $(VLT)))/../share/verilator
VLT_ROOT	   ?= ${VERILATOR_ROOT}

VERI_FLAGS         +=
VERI_COMPILE_FLAGS += -Wno-BLKANDNBLK $(SV_CMP_FLAGS) # hope this doesn't hurt us in the long run
VERI_TRACE         ?=
VERI_OBJ_DIR       ?= $(VLT_TOP_MODULE)_cobj_dir
#VERI_LOG_DIR       ?= cobj_dir/logs
VERI_LOG_DIR       ?= $(SIM_TEST_PROGRAM_RESULTS)
VERI_CFLAGS        += -O2

###############################################################################
# Verilator

# We first test if the user wants to to vcd dumping. This hacky part is required
# because we need to conditionally compile the testbench (-DVCD_TRACE) and pass
# the --trace flags to the verilator call
#ifeq ($(findstring +vcd,$(VERI_FLAGS)),+vcd)

VLT_FLAGS    += -Wno-fatal
VLT_CFLAGS   += -DTOPLEVEL_NAME=$(VLT_TOP_MODULE)
VLT_CFLAGS   += -std=c++17 

ifneq (${WAVES}, 0)
VERI_TRACE="--trace"
VLT_CFLAGS  += -DVCD_TRACE
endif

VLT_FLAGS    += --no-timing
VLT_FLAGS    += -O3
VLT_CFLAGS   +=  -O3  -I $(VLT_ROOT)/include -I $(VLT_ROOT)/include/vltstd  
#VLT_CFLAGS   +=  -O3 -fno-var-tracking-assignments -I $(VLT_ROOT)/include -I $(VLT_ROOT)/include/vltstd  

verilate: testbench_verilator


testbench_verilator:  $(TBSRC_VERI) 
	@echo "$(BANNER)"
	@echo "* Compiling  with Verilator"
	@echo "$(BANNER)"
	$(VERILATOR) --cc --sv --exe \
		$(VERI_TRACE) \
		$(VLT_FLAGS)   \
		--Wno-lint --Wno-UNOPTFLAT \
		--Wno-MODDUP  \
		 $(TBSRC_VERI) \
		-f $(CV_CORE_MANIFEST) \
		-f $(PE_MANIFEST) \
		--Mdir $(VERI_OBJ_DIR) \
		-CFLAGS "$(VLT_CFLAGS)"  \
		-LDFLAGS "-pthread -lutil -lelf" \
		$(VERI_COMPILE_FLAGS)
	$(MAKE) -C $(VERI_OBJ_DIR) -j$(num_cores_half) -f V$(VLT_TOP_MODULE).mk
	mkdir -p $(SIM_RESULTS)
	mv $(VERI_OBJ_DIR)/V$(VLT_TOP_MODULE) $(SIM_RESULTS)/verilator_executable

# verilator specific cleanup
veri-clean: verilate-clean

verilate-clean: 
	if [ -d $(SIM_RESULTS)   ]; then rm -r $(SIM_RESULTS);  fi
	if [ -d $(VERI_OBJ_DIR)  ]; then rm -r $(VERI_OBJ_DIR); fi
	rm -rf testbench_verilator
	if [ -e memory_dump.bin  ]; then rm memory_dump.bin;    fi
	if [ -e verilator_tb.vcd ]; then rm verilator_tb.vcd;   fi


###############################################################################

